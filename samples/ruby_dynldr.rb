#    This file is part of Metasm, the Ruby assembly manipulation suite
#    Copyright (C) 2006-2009 Yoann GUILLOT
#
#    Licence is LGPL, see LICENCE in the top-level directory

# This sample creates the dynldr.so ruby shared object that allows interaction with
# native libraries
# x86 only for now

require 'metasm'

module Metasm
module DynLdr
	# basic C defs for ruby internals - probably 1.8/x86 only
	RUBY_H = <<EOS
typedef unsigned long VALUE;

struct rb_string_t {
	long flags;
	VALUE klass;
	long len;
	char *ptr;
	union {
		long capa;
		VALUE shared;
	} aux;
};
#define RString(x) ((struct rb_string_t *)(x))

struct rb_array_t {
	long flags;
	VALUE klass;
	long len;
	union {
		long capa;
		VALUE shared;
	} aux;
	VALUE *ptr;
};
#define RArray(x) ((struct rb_array_t *)(x))


extern VALUE rb_cObject;
extern VALUE rb_eRuntimeError;
extern VALUE rb_eArgError;

#define Qfalse ((VALUE)0)
#define Qtrue  ((VALUE)2)
#define Qnil   ((VALUE)4)

#define T_STRING 0x07
#define T_ARRAY  0x09
#define T_FIXNUM 0x0a
#define T_MASK   0x3f
#define TYPE(x) ((int)(x) & 1 ? T_FIXNUM : ((int)(x) & 6) ? 0x40 : RString(x)->flags & T_MASK)

VALUE rb_uint2inum(unsigned long);
VALUE rb_ull2inum(unsigned long long);
unsigned long rb_num2ulong(VALUE);
VALUE rb_str_new(const char* ptr, long len);	// alloc + memcpy + 0term
VALUE rb_ary_new2(int len);

int rb_intern(char *);
VALUE rb_funcall(VALUE recv, int id, int nargs, ...);
VALUE rb_const_get(VALUE, int);
VALUE rb_raise(VALUE, char*);
void rb_define_method(VALUE, char *, VALUE (*)(), int);
void rb_define_const(VALUE, char *, VALUE);
void rb_define_singleton_method(VALUE, char *, VALUE (*)(), int);

EOS

	DYNLDR_C = <<EOS

#{RUBY_H}

// arch-specific linkage
int os_load_lib(char *lib);
int os_load_sym(int lib, char *ssym;
int os_load_sym_ord(int lib, int sym);

// asm linkage
__int64 do_invoke(int, int, int*);
__int64 do_invoke_stdcall(int, int, int*);
__int64 do_invoke_fastcall(int, int, int*);
VALUE do_return_float(void);
extern int *cb_ret_table;
extern void *callback_handler;

static VALUE dynldr;


static VALUE memory_read(VALUE self, VALUE addr, VALUE len)
{
	return rb_str_new((char*)rb_num2ulong(addr), (int)rb_num2ulong(len));
}

static VALUE memory_write(VALUE self, VALUE addr, VALUE val)
{
	char *src = RString(val)->ptr;
	char *dst = (char*)rb_num2ulong(addr);
	int len = RString(val)->len;
	while (len--)
		*dst++ = *src++;
	return val;
}

/*
static VALUE memory_alloc(VALUE self, VALUE sz)
{
	return rb_uint2inum((int)os_mem_alloc(rb_num2ulong(sz)));
}

static VALUE memory_free(VALUE self, VALUE addr)
{
	os_mem_free((void*)rb_num2ulong(addr));
	return Qtrue;
}

// perm: 1 read 2 write 4 exec
static VALUE memory_perm(VALUE self, VALUE addr, VALUE len, VALUE perm)
{
	os_mem_perm((void*)rb_num2ulong(addr), rb_num2ulong(len), rb_num2ulong(perm))
	return Qtrue;
}
*/

static VALUE str_ptr(VALUE self, VALUE str)
{
	if (TYPE(lib) != T_STRING)
		rb_raise(rb_eArgError, "Invalid ptr");
	return rb_uint2inum((unsigned int)RString(str)->ptr);
}

// load a symbol from a lib byname, byordinal if integral
static VALUE sym_addr(VALUE self, VALUE lib, VALUE func)
{
	int h, p;

	if (TYPE(lib) != T_STRING)
		rb_raise(rb_eArgError, "Invalid lib");
	if (TYPE(func) != T_STRING && TYPE(func) != T_FIXNUM)
		rb_raise(rb_eArgError, "Invalid func");
	
	h = os_load_lib(RString(lib)->ptr);

	if (TYPE(func) == T_FIXNUM)
		p = os_load_sym_ord(h, rb_num2ulong(func));
	else
		p = os_load_sym(h, RString(func)->ptr);

	return rb_uint2inum(p);
}

// invoke a symbol
// args is an array of Integers
// flags: 1 stdcall  2 fastcall  4 ret 64bits  8 ret float
// TODO float args
static VALUE invoke(VALUE self, VALUE ptr, VALUE args, VALUE flags)
{
	if (TYPE(args) != T_ARRAY || RArray(args)->len > 64)
		rb_raise(rb_eArgError, "bad args");
	
	int flags_v = rb_num2ulong(flags);
	int ptr_v = rb_num2ulong(flags);
	int i, argsz;
	int args[64];
	__int64 ret;

	argsz = RArray(args)->len;
	for (i=0 ; i<argsz ; i++)
		args[i] = rb_num2ulong(RArray(args)->ptr[i]);

	if (flags_v & 1)
		ret = do_invoke_stdcall(ptr_v, argsz, args);
	elsif (flags_v & 2)
		ret = do_invoke_fastcall(ptr_v, argsz, args);
	else
		ret = do_invoke(ptr_v, argsz, args);
	
	if (flags_v & 4)
		return rb_ull2inum(ret);
	elsif (flags_v & 8)
		return do_return_float();
	else
		return rb_uint2inum(ret);
}

// this is the function that is called on behalf of all callbacks
// we're called through callback_handler (asm), itself called from the unique
// callback generated by new_callback
// heavy stack magick at work here !
// TODO float args / float retval / ret __int64
static int do_callback_handler(int caller_id, int arg0)
{
	int *addr = &arg0;
	int i;
	VALUE args = rb_ary_new2(8);

	// copy our args to a ruby-accessible buffer
	for (i=0 ; i<8 ; i++)
		RArray(args)->ptr[i] = rb_uint2inum(*addr++);

	ret = rb_funcall(dynldr, rb_intern("run_callback"), 2, rb_uint2inum(caller_id), args);

	// dynldr.callback will give us the arity of the callback in args[0]
	// now we can fix our return address to match the caller's expectations
	addr = &caller_id;
	addr[-1] += cb_ret_table[rb_num2ulong(RArray(args)->ptr[0])];
	
	return rb_num2ulong(ret);
}

int Init_dynldr(void) __attribute__((export))
{
	dynldr = rb_const_get(rb_const_get(rb_cObject, rb_intern("Metasm")), rb_intern("DynLdr"));
	rb_define_singleton_method(dynldr, "memory_read",  memory_read, 2);
	rb_define_singleton_method(dynldr, "memory_write", memory_write, 2);
/*
	rb_define_singleton_method(dynldr, "memory_alloc", memory_alloc, 1);
	rb_define_singleton_method(dynldr, "memory_free",  memory_free, 1);
	rb_define_singleton_method(dynldr, "memory_perm",  memory_perm, 3);
*/
	rb_define_singleton_method(dynldr, "str_ptr", str_ptr, 1);
	rb_define_singleton_method(dynldr, "sym_addr", sym_addr, 2);
	rb_define_singleton_method(dynldr, "raw_invoke", invoke, 3);
	rb_define_const(dynldr, "CALLBACK_TARGET", rb_uint2inum(callback_handler));
	return 0;
}
EOS

	DYNLDR_ASM = <<EOS
do_invoke_fastcall:
	push ebp
	mov ebp, esp
	
	// load ecx/edx, fix arg/argcount
	mov eax, [ebp+16]
	mov ecx, [eax]
	mov edx, [eax+4]
	add eax, 8
	mov [ebp+16], eax

	mov eax,[ebp+12]
	test eax, eax
	jz _do_invoke_call
	dec eax
	test eax, eax
	jz _do_invoke_call
	dec eax
	jmp _do_invoke_copy

do_invoke:
do_invoke_stdcall:
	push ebp
	mov ebp, esp
	mov eax, [ebp+12]
_do_invoke_copy:
	// make room for args
	shr eax, 2
	jz _do_invoke_call
	sub esp, eax
	// copy args
	push esi
	push edi
	push ecx
	mov ecx, [ebp+12]
	mov esi, [ebp+16]
	mov edi, esp
	add edi, 12
	rep movsd
	pop ecx
	pop edi
	pop esi
	// go
_do_invoke_call:
	call dword ptr [ebp+8]
	leave
	ret

do_return_float:
	call rb_float_new
	ret

// entrypoint for callbacks: to the native api, give the addr of some code
//  that will push a unique cb_identifier and jmp here
callback_handler:
	// swap caller retaddr & cb_identifier
	pop eax
	xchg eax, [esp]
	push eax
	call do_callback_handler
	// do_cb_h may replace its retaddr with do_ret_XX if cb is stdcall

// stuff used by the callback handler to emulate __stdcall callbacks
cb_ret_0: ret 4 	// no arg/cdecl		(still need to remove the cb_id)
cb_ret_1: ret 8 	// stdcall 1arg
cb_ret_2: ret 12	// stdcall 2args
cb_ret_3: ret 16	// stdcall 3args
cb_ret_4: ret 20	//         4
cb_ret_5: ret 24	//         5
cb_ret_6: ret 28	//         6
cb_ret_7: ret 32	//         7
cb_ret_8: ret 36	//         8args
// table holding the retaddr adjustment to make from the desired arity
cb_ret_table dd #{(0..8).map { |i| "cb_ret_#{i} - cb_ret_0" }.join(', ')}
EOS

	DYNLDR_C_WIN = <<EOS
__stdcall int LoadLibraryA(char *);
__stdcall int GetProcAddress(int, char *);

int os_load_lib(char *lib)
{
	return LoadLibraryA(lib);
}

asm("os_load_sym_ord: jmp os_load_sym");
int os_load_sym(int lib, char *sym)
{
	return GetProcAddress(lib, sym);
}
EOS
		

	def self.start
		binmodule = 'dynldr.so'

		if not File.exists? binmodule
			exe = PE.new(cpu)
			exe.compile_c(DYNLDR_C_WIN)
			exe.assemble(DYNLDR_ASM)
			exe.compile_c(DYNLDR_C)
			exe.encode_file(binmodule)
		end

		require binmodule
		@raw_ptr = {}
	end

	def self.cpu ; @cpu ||= Ia32.new end


	def self.new_api_c(proto, lib=nil)
		cp = cpu.new_cparser
		cp.parse(proto)

		cp.toplevel.symbol.each_value { |v|
			# TODO autodiscover lib (autoimports?)
			@raw_ptr[lib] ||= {}
			@raw_ptr[lib][v.name] = sym_addr(lib, v.name)

			if not v.type.kind_of? C::Function
				# struct/table access ?
				define_method(v.name.downcase) { @raw_ptr[lib][v.name] }
				next
			end

			next if v.initializer	# inline & stuff

			new_api_c_func(v)
		}

		cp.parser.definition.each_key { |k|
			if val = cp.macro_numeric_value(k)
				const_set(k.upcase, val)
			end
		}
	end

	def self.new_api_c_func(v)
		flags = 0
		flags |= 1 if v.type.has_attribute('stdcall')
		flags |= 2 if v.type.has_attribute('fastcall')
		define_method(v.name.downcase) { |*a|
			raise "bad arg count for #{v.name}: #{a.length} for #{v.type.args.length}" if a.length != v.type.args.length
			a = convert_args(a)
			raw_invoke(@raw_ptr[lib][v.name], a, flags)
		}
	end

	def self.run_callback(id, args)
		id -= 5		# sizeof(call callback_handler)
		cb = @callback_table[id]
		ret = cb[:proc][self, args]
		args[0] = cb[:abi_stackfix] || 0
		ret
	end

	def self.new_callback(proto, &b)
		cb = { :proc => b }
		cp = cpu.new_cparser
		cp.parse(proto)

		v = cp.toplevel.symbol.values.find_all { |v| v.type.kind_of? C::Function }.first
		# TODO allow C body ?
		cp[:abi_stackfix] = v.type.args.length if v.type.has_attribute('stdcall')
		id = find_new_callback_id
		@callback_table[id] = cp
		id
	end

	new_api_c <<EOS, 'kernel32'
#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     
#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     
#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     
#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_RESET           0x80000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_WRITE_WATCH    0x200000     
#define MEM_PHYSICAL       0x400000     
#define MEM_LARGE_PAGES  0x20000000     
#define MEM_4MB_PAGES    0x80000000     

__stdcall int VirtualAlloc(int addr, int size, int type, int prot);
__stdcall int VirtualFree(int addr, int size, int freetype);
__stdcall int VirtualProtect(int addr, int size, int prot, int *oldprot);
EOS
	
	def self.memory_alloc(sz)
		virtualalloc(0, sz, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE)
	end

	def self.memory_free(addr)
		virtualfree(addr, 0, MEM_DECOMMIT|MEM_RELEASE)
	end

	def self.memory_prot(addr, len, perm)
		virtualprotect()
	end

	# automatically build/load the bin module
	start
end
end
