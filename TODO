disasm:
 handle delay slot
 data xref: trackback memory write/read (read is when you read a value and modify it/its derivates, (!= push eax ; trash ; pop eax)) - detect self-modifying code
 remove maxdepth param? + detect loops
 path-specific backtracking ( foo: call a ; a: jmp retloc ; bar: call b ; b: jmp retloc ; retloc: ret ; call foo ; ret : last ret trackback should only reach a:)
 disasm some code sequences to C
 externs / C header parser (prototypes, + OS abi ?)
 somehow handle unknown external calls (fake func body with special 'trashed' backtrack instruction to allow abi like 'ebp is kept, eax is mutable' ? could need something like stack not accessed below [esp+12])
 gui
 allow program-wide label renaming

ia32: emu fpu
mips: cpu emu for trackback
encode: SplitReloc for pseudo-instrs (mips li => reloc high :a16 + reloc low :a16), use Reloc.encode(edata, off) or sumthin for edata.fixup (allows ducktyping)
asm:  asmpp.pp (instead of asm < pp)
optimizer/deoptimizer (asm/dasm): reorder instructions
